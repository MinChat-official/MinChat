import org.gradle.internal.impldep.org.intellij.lang.annotations.Language
import org.jetbrains.kotlin.gradle.tasks.KotlinCompile
import org.jetbrains.kotlin.util.suffixIfNot

plugins {
	kotlin("jvm") version "1.9.20"
	kotlin("plugin.serialization") version "1.9.20"
}

val ktorVersion: String by rootProject

dependencies {
	implementation(project(":minchat-common"))

	implementation("io.ktor", "ktor-client-core", ktorVersion)
	implementation("io.ktor", "ktor-client-cio", ktorVersion)
	implementation("io.ktor", "ktor-client-content-negotiation", ktorVersion)
	implementation("io.ktor", "ktor-serialization-kotlinx-json", ktorVersion)
	implementation("io.ktor", "ktor-client-websockets", ktorVersion)

	implementation("org.mindrot", "jbcrypt", "0.4")
}

val generateCacheService by tasks.registering {
	@Language("kotlin")
	val prefix = """
		//
		// THIS CLASS IS GENERATED BY THE generateCacheSerivce gradle task!
		// DO NOT MODIFY BY HAND!
		//
		
		package io.minchat.rest.service
		
		import io.minchat.common.entity.*
		import io.minchat.rest.MinchatRestClient
		import io.minchat.rest.entity.*
		
		/**
		 * Allows fetching MinChat entities using a caching strategy.
		 */
		class CacheService(
			baseUrl: String,
			val minchatClient: MinchatRestClient
		) : AbstractRestService(baseUrl, minchatClient.httpClient) {
		
		/** Up to how many entities of each type can be cached. */
		var maxCacheSize = 100
	""".trimIndent()
	val suffix = "}"

	val cacheTypes = listOf("Message", "User", "Channel", "ChannelGroup")
	val output = projectDir.resolve("src/main/kotlin/io/minchat/rest/service/CacheService.kt")
	outputs.upToDateWhen { false }

	doLast {
		val cacheLists = cacheTypes.map { "val ${it.lowercase()}Cache = mutableMapOf<Long, $it?>()" }
			.joinToString("\n")
			.suffixIfNot("\n")

		val setMethods = cacheTypes.map {
			val cache = it.lowercase() + "Cache"
			//language=kotlin
			"""
				/** Adds the $it to the $cache, potentially overriding the previous version. */
				fun set(entity: $it) {
					$cache[entity.id] = entity
				}
				
				/** Adds the Minchat$it to the $cache, potentially overriding the previous version. */
				fun set(entity: Minchat$it) {
					$cache[entity.id] = entity.data
				}
			""".trimIndent()
		}.joinToString("\n\n")

		val getMethods = cacheTypes.map {
			val cache = it.lowercase() + "Cache"

			//language=kotlin
			"""
				/** Gets a $it from $cache. If [restFallback] is true, attempts to fetch the $it if it's absent in the cache. */
				suspend fun getRaw$it(id: Long, restFallback: Boolean = true): $it? {
					val data = $cache[id]
			
					if (data == null) {
						if (!restFallback) return null
						return minchatClient.get$it(id).data.also {
							set(it)
						}
					} else {
						return data
					}
				}

				/** Gets a Minchat$it from $cache. If [restFallback] is true, attempts to fetch the Minchat$it if it's absent in the cache. */
				suspend fun get$it(id: Long, restFallback: Boolean = true): Minchat$it? =
					getRaw$it(id, restFallback)?.withClient(minchatClient)
			""".trimIndent()
		}.joinToString("\n\n")

		val classBody = listOf(cacheLists, getMethods, setMethods)
			.joinToString("\n")
			.lineSequence()
			.map { "\t$it" } // indent
			.joinToString("\n")

		output.writeText(
			listOf(prefix, classBody, suffix).joinToString("\n")
		)
	}
}

tasks.withType<KotlinCompile> {
	dependsOn(generateCacheService)
}
