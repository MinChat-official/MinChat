//
// THIS CLASS IS GENERATED BY THE generateCacheSerivce gradle task!
// DO NOT MODIFY BY HAND!
//

package io.minchat.rest.service

import io.minchat.common.entity.*
import io.minchat.rest.MinchatRestClient
import io.minchat.rest.entity.*

/**
 * Allows fetching MinChat entities using a caching strategy.
 */
class CacheService(
	baseUrl: String,
	val minchatClient: MinchatRestClient
) : AbstractRestService(baseUrl, minchatClient.httpClient) {

/** Up to how many entities of each type can be cached. */
var maxCacheSize = 100
	val messageCache = mutableMapOf<Long, Message?>()
	val userCache = mutableMapOf<Long, User?>()
	val channelCache = mutableMapOf<Long, Channel?>()
	val channelgroupCache = mutableMapOf<Long, ChannelGroup?>()
	
	/** Gets a Message from messageCache. If [restFallback] is true, attempts to fetch the Message if it's absent in the cache. */
	suspend fun getRawMessage(id: Long, restFallback: Boolean = true): Message? {
		val data = messageCache[id]
	
		if (data == null) {
			if (!restFallback) return null
			return minchatClient.getMessage(id).data.also {
				set(it)
			}
		} else {
			return data
		}
	}
	
	/** Gets a MinchatMessage from messageCache. If [restFallback] is true, attempts to fetch the MinchatMessage if it's absent in the cache. */
	suspend fun getMessage(id: Long, restFallback: Boolean = true): MinchatMessage? =
		getRawMessage(id, restFallback)?.withClient(minchatClient)
	
	/** Gets a User from userCache. If [restFallback] is true, attempts to fetch the User if it's absent in the cache. */
	suspend fun getRawUser(id: Long, restFallback: Boolean = true): User? {
		val data = userCache[id]
	
		if (data == null) {
			if (!restFallback) return null
			return minchatClient.getUser(id).data.also {
				set(it)
			}
		} else {
			return data
		}
	}
	
	/** Gets a MinchatUser from userCache. If [restFallback] is true, attempts to fetch the MinchatUser if it's absent in the cache. */
	suspend fun getUser(id: Long, restFallback: Boolean = true): MinchatUser? =
		getRawUser(id, restFallback)?.withClient(minchatClient)
	
	/** Gets a Channel from channelCache. If [restFallback] is true, attempts to fetch the Channel if it's absent in the cache. */
	suspend fun getRawChannel(id: Long, restFallback: Boolean = true): Channel? {
		val data = channelCache[id]
	
		if (data == null) {
			if (!restFallback) return null
			return minchatClient.getChannel(id).data.also {
				set(it)
			}
		} else {
			return data
		}
	}
	
	/** Gets a MinchatChannel from channelCache. If [restFallback] is true, attempts to fetch the MinchatChannel if it's absent in the cache. */
	suspend fun getChannel(id: Long, restFallback: Boolean = true): MinchatChannel? =
		getRawChannel(id, restFallback)?.withClient(minchatClient)
	
	/** Gets a ChannelGroup from channelgroupCache. If [restFallback] is true, attempts to fetch the ChannelGroup if it's absent in the cache. */
	suspend fun getRawChannelGroup(id: Long, restFallback: Boolean = true): ChannelGroup? {
		val data = channelgroupCache[id]
	
		if (data == null) {
			if (!restFallback) return null
			return minchatClient.getChannelGroup(id).data.also {
				set(it)
			}
		} else {
			return data
		}
	}
	
	/** Gets a MinchatChannelGroup from channelgroupCache. If [restFallback] is true, attempts to fetch the MinchatChannelGroup if it's absent in the cache. */
	suspend fun getChannelGroup(id: Long, restFallback: Boolean = true): MinchatChannelGroup? =
		getRawChannelGroup(id, restFallback)?.withClient(minchatClient)
	/** Adds the Message to the messageCache, potentially overriding the previous version. */
	fun set(entity: Message) {
		messageCache[entity.id] = entity
	}
	
	/** Adds the MinchatMessage to the messageCache, potentially overriding the previous version. */
	fun set(entity: MinchatMessage) {
		messageCache[entity.id] = entity.data
	}
	
	/** Adds the User to the userCache, potentially overriding the previous version. */
	fun set(entity: User) {
		userCache[entity.id] = entity
	}
	
	/** Adds the MinchatUser to the userCache, potentially overriding the previous version. */
	fun set(entity: MinchatUser) {
		userCache[entity.id] = entity.data
	}
	
	/** Adds the Channel to the channelCache, potentially overriding the previous version. */
	fun set(entity: Channel) {
		channelCache[entity.id] = entity
	}
	
	/** Adds the MinchatChannel to the channelCache, potentially overriding the previous version. */
	fun set(entity: MinchatChannel) {
		channelCache[entity.id] = entity.data
	}
	
	/** Adds the ChannelGroup to the channelgroupCache, potentially overriding the previous version. */
	fun set(entity: ChannelGroup) {
		channelgroupCache[entity.id] = entity
	}
	
	/** Adds the MinchatChannelGroup to the channelgroupCache, potentially overriding the previous version. */
	fun set(entity: MinchatChannelGroup) {
		channelgroupCache[entity.id] = entity.data
	}
}